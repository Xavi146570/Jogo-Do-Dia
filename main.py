#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üöÄ Bot Inteligente de Monitoramento de Futebol - SISTEMA AUTOM√ÅTICO COMPLETO
üìä Sistema de aproxima√ß√£o √† m√©dia + Cash Out + DETEC√á√ÉO AUTOM√ÅTICA
üéØ Vers√£o com todas as funcionalidades autom√°ticas restauradas

FUNCIONALIDADES AUTOM√ÅTICAS:
- üîç Detec√ß√£o autom√°tica de jogos das equipes cadastradas
- üö® Alertas autom√°ticos para jogos importantes  
- ‚è∞ Monitoramento de fixtures por continente/liga
- üìä Tracking ao vivo de oportunidades
- üí∞ Recomenda√ß√µes Cash Out autom√°ticas
"""

import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
import asyncio
import sys
import json
import aiohttp
from dataclasses import dataclass

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    CallbackQueryHandler, 
    ContextTypes,
    MessageHandler,
    filters,
    JobQueue
)

# Configura√ß√£o do logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class GameAlert:
    home_team: str
    away_team: str
    kickoff: str
    league: str
    home_zero_percent: float
    away_zero_percent: float
    opportunity_level: str
    cash_out_home: str
    cash_out_away: str

class AutomaticFootballBot:
    def __init__(self):
        """Bot com sistema autom√°tico completo"""
        
        # üåç BASE GLOBAL: 102 EQUIPES (mantendo dados atuais)
        self.teams_data = {
            # üá©üá™ ALEMANHA - BUNDESLIGA (Elite)
            "Bayern Munich": {"zero_percent": 2.1, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "Bayern Munich"},
            "Borussia Dortmund": {"zero_percent": 3.4, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "Borussia Dortmund"},
            "RB Leipzig": {"zero_percent": 4.2, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "RB Leipzig"},
            "Bayer Leverkusen": {"zero_percent": 3.8, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "Bayer 04 Leverkusen"},
            "Eintracht Frankfurt": {"zero_percent": 5.1, "continent": "Europa", "league": "Bundesliga", "tier": "premium", "api_name": "Eintracht Frankfurt"},
            "Borussia M'gladbach": {"zero_percent": 5.7, "continent": "Europa", "league": "Bundesliga", "tier": "premium", "api_name": "Borussia Monchengladbach"},
            "Wolfsburg": {"zero_percent": 6.2, "continent": "Europa", "league": "Bundesliga", "tier": "premium", "api_name": "VfL Wolfsburg"},
            "Union Berlin": {"zero_percent": 6.8, "continent": "Europa", "league": "Bundesliga", "tier": "standard", "api_name": "Union Berlin"},
            
            # üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø INGLATERRA - PREMIER LEAGUE (Elite)
            "Manchester City": {"zero_percent": 1.8, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Manchester City"},
            "Liverpool": {"zero_percent": 2.3, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Liverpool"},
            "Arsenal": {"zero_percent": 2.9, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Arsenal"},
            "Chelsea": {"zero_percent": 3.1, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Chelsea"},
            "Manchester United": {"zero_percent": 3.7, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Manchester United"},
            "Tottenham": {"zero_percent": 4.1, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Tottenham"},
            "Newcastle": {"zero_percent": 4.8, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "Newcastle United"},
            "Brighton": {"zero_percent": 5.4, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "Brighton & Hove Albion"},
            "West Ham": {"zero_percent": 5.9, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "West Ham United"},
            "Aston Villa": {"zero_percent": 6.1, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "Aston Villa"},
            "Crystal Palace": {"zero_percent": 6.7, "continent": "Europa", "league": "Premier League", "tier": "standard", "api_name": "Crystal Palace"},
            
            # üá™üá∏ ESPANHA - LA LIGA (Elite)
            "Real Madrid": {"zero_percent": 1.9, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "Real Madrid"},
            "Barcelona": {"zero_percent": 2.4, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "FC Barcelona"},
            "Atletico Madrid": {"zero_percent": 3.2, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "Atletico Madrid"},
            "Real Sociedad": {"zero_percent": 4.3, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "Real Sociedad"},
            "Villarreal": {"zero_percent": 4.7, "continent": "Europa", "league": "La Liga", "tier": "premium", "api_name": "Villarreal"},
            "Athletic Bilbao": {"zero_percent": 5.2, "continent": "Europa", "league": "La Liga", "tier": "premium", "api_name": "Athletic Club"},
            "Real Betis": {"zero_percent": 5.8, "continent": "Europa", "league": "La Liga", "tier": "premium", "api_name": "Real Betis"},
            "Valencia": {"zero_percent": 6.4, "continent": "Europa", "league": "La Liga", "tier": "standard", "api_name": "Valencia"},
            "Sevilla": {"zero_percent": 6.9, "continent": "Europa", "league": "La Liga", "tier": "standard", "api_name": "Sevilla"},
            
            # üáÆüáπ IT√ÅLIA - SERIE A (Elite)
            "Inter Milan": {"zero_percent": 2.7, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "Inter"},
            "AC Milan": {"zero_percent": 3.3, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "AC Milan"},
            "Juventus": {"zero_percent": 3.9, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "Juventus"},
            "Napoli": {"zero_percent": 4.1, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "Napoli"},
            "AS Roma": {"zero_percent": 4.6, "continent": "Europa", "league": "Serie A", "tier": "premium", "api_name": "AS Roma"},
            "Lazio": {"zero_percent": 5.3, "continent": "Europa", "league": "Serie A", "tier": "premium", "api_name": "Lazio"},
            "Atalanta": {"zero_percent": 5.7, "continent": "Europa", "league": "Serie A", "tier": "premium", "api_name": "Atalanta"},
            "Fiorentina": {"zero_percent": 6.3, "continent": "Europa", "league": "Serie A", "tier": "standard", "api_name": "Fiorentina"},
            
            # üá´üá∑ FRAN√áA - LIGUE 1 (Elite)
            "PSG": {"zero_percent": 2.1, "continent": "Europa", "league": "Ligue 1", "tier": "elite", "api_name": "Paris Saint Germain"},
            "AS Monaco": {"zero_percent": 4.2, "continent": "Europa", "league": "Ligue 1", "tier": "elite", "api_name": "AS Monaco"},
            "Olympique Lyon": {"zero_percent": 4.8, "continent": "Europa", "league": "Ligue 1", "tier": "premium", "api_name": "Olympique Lyonnais"},
            "Marseille": {"zero_percent": 5.4, "continent": "Europa", "league": "Ligue 1", "tier": "premium", "api_name": "Olympique Marseille"},
            "Lille": {"zero_percent": 5.9, "continent": "Europa", "league": "Ligue 1", "tier": "premium", "api_name": "Lille"},
            "Nice": {"zero_percent": 6.5, "continent": "Europa", "league": "Ligue 1", "tier": "standard", "api_name": "Nice"},
            
            # üá≥üá± HOLANDA - EREDIVISIE
            "Ajax": {"zero_percent": 3.1, "continent": "Europa", "league": "Eredivisie", "tier": "elite", "api_name": "Ajax"},
            "PSV": {"zero_percent": 3.6, "continent": "Europa", "league": "Eredivisie", "tier": "elite", "api_name": "PSV"},
            "Feyenoord": {"zero_percent": 4.4, "continent": "Europa", "league": "Eredivisie", "tier": "elite", "api_name": "Feyenoord"},
            "AZ Alkmaar": {"zero_percent": 5.8, "continent": "Europa", "league": "Eredivisie", "tier": "premium", "api_name": "AZ"},
            
            # üáµüáπ PORTUGAL - PRIMEIRA LIGA
            "FC Porto": {"zero_percent": 3.4, "continent": "Europa", "league": "Primeira Liga", "tier": "elite", "api_name": "FC Porto"},
            "Benfica": {"zero_percent": 3.8, "continent": "Europa", "league": "Primeira Liga", "tier": "elite", "api_name": "Benfica"},
            "Sporting CP": {"zero_percent": 4.2, "continent": "Europa", "league": "Primeira Liga", "tier": "elite", "api_name": "Sporting CP"},
            "SC Braga": {"zero_percent": 6.1, "continent": "Europa", "league": "Primeira Liga", "tier": "premium", "api_name": "SC Braga"},
            
            # üáßüá∑ BRASIL - S√âRIE A (Am√©rica do Sul)
            "Flamengo": {"zero_percent": 3.2, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "elite", "api_name": "Flamengo"},
            "Palmeiras": {"zero_percent": 3.7, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "elite", "api_name": "Palmeiras"},
            "S√£o Paulo": {"zero_percent": 4.1, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "elite", "api_name": "Sao Paulo"},
            "Atl√©tico-MG": {"zero_percent": 4.6, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "premium", "api_name": "Atletico Mineiro"},
            "Internacional": {"zero_percent": 5.2, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "premium", "api_name": "Internacional"},
            "Gr√™mio": {"zero_percent": 5.7, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "premium", "api_name": "Gremio"},
            "Corinthians": {"zero_percent": 6.3, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "standard", "api_name": "Corinthians"},
            "Santos": {"zero_percent": 6.8, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "standard", "api_name": "Santos"},
            
            # üá¶üá∑ ARGENTINA - PRIMERA DIVISI√ìN
            "River Plate": {"zero_percent": 3.5, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "elite", "api_name": "River Plate"},
            "Boca Juniors": {"zero_percent": 4.1, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "elite", "api_name": "Boca Juniors"},
            "Racing Club": {"zero_percent": 5.4, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "premium", "api_name": "Racing Club"},
            "Independiente": {"zero_percent": 6.2, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "standard", "api_name": "Independiente"},
            "San Lorenzo": {"zero_percent": 6.7, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "standard", "api_name": "San Lorenzo"},
            
            # üá∫üá∏ ESTADOS UNIDOS - MLS (Am√©rica do Norte)
            "LAFC": {"zero_percent": 4.3, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "elite", "api_name": "Los Angeles FC"},
            "Atlanta United": {"zero_percent": 4.8, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "Atlanta United FC"},
            "Seattle Sounders": {"zero_percent": 5.1, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "Seattle Sounders FC"},
            "Inter Miami": {"zero_percent": 5.6, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "Inter Miami CF"},
            "New York City FC": {"zero_percent": 6.0, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "New York City FC"},
            "Portland Timbers": {"zero_percent": 6.4, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "standard", "api_name": "Portland Timbers"},
        }
        
        # üîÑ Sistema de monitoramento autom√°tico
        self.monitored_users = set()  # Usu√°rios que ativaram alertas
        self.detected_games = {}      # Jogos detectados hoje
        self.sent_alerts = set()      # Alertas j√° enviados (evitar spam)
        
        # üìä Configura√ß√µes do sistema autom√°tico
        self.auto_check_interval = 300  # 5 minutos entre verifica√ß√µes
        self.daily_reset_time = "06:00"  # Reset di√°rio √†s 6h
        
        # üéØ Simula√ß√£o API (ser√° substitu√≠da por API real)
        self.mock_fixtures_today = [
            {
                "home_team": "FC Porto", 
                "away_team": "Estrela Vermelha", 
                "kickoff": "21:00",
                "competition": "Liga Europa",
                "date": "2024-10-02"
            },
            {
                "home_team": "Bayern Munich", 
                "away_team": "Bayer Leverkusen", 
                "kickoff": "18:30",
                "competition": "Bundesliga", 
                "date": "2024-10-02"
            },
            {
                "home_team": "Manchester City", 
                "away_team": "Liverpool", 
                "kickoff": "17:00",
                "competition": "Premier League",
                "date": "2024-10-02"
            }
        ]
        
        logger.info(f"ü§ñ Bot autom√°tico inicializado com {len(self.teams_data)} equipes")

    async def start_automatic_monitoring(self, context: ContextTypes.DEFAULT_TYPE):
        """Inicia o sistema de monitoramento autom√°tico"""
        logger.info("üîÑ Iniciando monitoramento autom√°tico de jogos...")
        
        # Verificar jogos a cada 5 minutos
        context.job_queue.run_repeating(
            self.auto_check_games,
            interval=self.auto_check_interval,
            first=10  # Primeira verifica√ß√£o em 10 segundos
        )
        
        # Reset di√°rio √†s 6h da manh√£
        context.job_queue.run_daily(
            self.daily_reset,
            time=datetime.strptime(self.daily_reset_time, "%H:%M").time()
        )
        
        logger.info("‚úÖ Sistema autom√°tico ativado!")

    async def auto_check_games(self, context: ContextTypes.DEFAULT_TYPE):
        """Verifica√ß√£o autom√°tica de jogos (executada a cada 5 minutos)"""
        try:
            logger.info("üîç Verificando jogos autom√°ticos...")
            
            today = datetime.now().strftime("%Y-%m-%d")
            detected_count = 0
            
            # Simular busca de fixtures (aqui voc√™ conectaria √† API real)
            for fixture in self.mock_fixtures_today:
                if fixture["date"] == today.replace("-", "-"):
                    home_team = fixture["home_team"]
                    away_team = fixture["away_team"]
                    
                    # Verificar se alguma equipe est√° no nosso banco de dados
                    home_in_db = home_team in self.teams_data
                    away_in_db = away_team in self.teams_data
                    
                    if home_in_db or away_in_db:
                        game_key = f"{home_team}_vs_{away_team}_{fixture['kickoff']}"
                        
                        if game_key not in self.detected_games:
                            # Novo jogo detectado!
                            self.detected_games[game_key] = {
                                "home_team": home_team,
                                "away_team": away_team,
                                "kickoff": fixture["kickoff"],
                                "competition": fixture["competition"],
                                "home_in_db": home_in_db,
                                "away_in_db": away_in_db,
                                "detected_at": datetime.now()
                            }
                            
                            detected_count += 1
                            logger.info(f"üö® Novo jogo detectado: {home_team} vs {away_team}")
                            
                            # Enviar alertas para usu√°rios monitorados
                            await self.send_auto_alerts(context, self.detected_games[game_key])
            
            if detected_count > 0:
                logger.info(f"‚úÖ {detected_count} novos jogos detectados")
            else:
                logger.info("‚ÑπÔ∏è Nenhum jogo novo detectado")
                
        except Exception as e:
            logger.error(f"‚ùå Erro na verifica√ß√£o autom√°tica: {e}")

    async def send_auto_alerts(self, context: ContextTypes.DEFAULT_TYPE, game_data: Dict):
        """Envia alertas autom√°ticos para usu√°rios monitorados"""
        try:
            home_team = game_data["home_team"]
            away_team = game_data["away_team"]
            kickoff = game_data["kickoff"]
            competition = game_data["competition"]
            
            # Construir an√°lise do jogo
            analysis = self.build_game_analysis(home_team, away_team, competition)
            
            alert_message = f"""
üö® **JOGO DETECTADO AUTOMATICAMENTE!**

‚öΩ **{home_team}** vs **{away_team}**
üïí **Hor√°rio:** {kickoff}
üèÜ **Competi√ß√£o:** {competition}

{analysis}

ü§ñ **Alerta autom√°tico ativado**
üí° Use `/analise {home_team}` para detalhes
            """
            
            # Enviar para todos os usu√°rios monitorados
            for user_id in self.monitored_users:
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=alert_message,
                        parse_mode='Markdown'
                    )
                    logger.info(f"üì§ Alerta enviado para usu√°rio {user_id}")
                except Exception as e:
                    logger.error(f"‚ùå Erro ao enviar alerta para {user_id}: {e}")
                    # Remover usu√°rio se bloqueou o bot
                    if "blocked" in str(e).lower():
                        self.monitored_users.discard(user_id)
                        
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar alertas autom√°ticos: {e}")

    def build_game_analysis(self, home_team: str, away_team: str, competition: str) -> str:
        """Constr√≥i an√°lise autom√°tica do jogo"""
        analysis_parts = []
        
        # Analisar equipe da casa
        if home_team in self.teams_data:
            home_data = self.teams_data[home_team]
            home_cash_out = self.get_cash_out_recommendation(home_team)
            tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
            
            analysis_parts.append(f"""
üè† **{home_team}** {tier_emoji[home_data['tier']]}
‚Ä¢ **% 0x0:** {home_data['zero_percent']}%
‚Ä¢ **Tier:** {home_data['tier'].capitalize()}
‚Ä¢ **Recomenda√ß√£o:** {home_cash_out['recommendation']}
            """)
        else:
            analysis_parts.append(f"üè† **{home_team}** - N√£o cadastrado (>7% de 0x0)")
        
        # Analisar equipe visitante  
        if away_team in self.teams_data:
            away_data = self.teams_data[away_team]
            away_cash_out = self.get_cash_out_recommendation(away_team)
            tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
            
            analysis_parts.append(f"""
‚úàÔ∏è **{away_team}** {tier_emoji[away_data['tier']]}
‚Ä¢ **% 0x0:** {away_data['zero_percent']}%
‚Ä¢ **Tier:** {away_data['tier'].capitalize()}  
‚Ä¢ **Recomenda√ß√£o:** {away_cash_out['recommendation']}
            """)
        else:
            analysis_parts.append(f"‚úàÔ∏è **{away_team}** - N√£o cadastrado (>7% de 0x0)")
        
        # Recomenda√ß√£o geral do jogo
        home_qualified = home_team in self.teams_data
        away_qualified = away_team in self.teams_data
        
        if home_qualified and away_qualified:
            home_percent = self.teams_data[home_team]["zero_percent"]
            away_percent = self.teams_data[away_team]["zero_percent"]
            avg_percent = (home_percent + away_percent) / 2
            
            analysis_parts.append(f"""
üéØ **AN√ÅLISE DO JOGO:**
‚Ä¢ **M√©dia 0x0:** {avg_percent:.1f}%
‚Ä¢ **Status:** Ambas qualificadas ‚úÖ
‚Ä¢ **Oportunidade:** EXCELENTE para Over 0.5
‚Ä¢ **Confian√ßa:** MUITO ALTA
            """)
        elif home_qualified or away_qualified:
            qualified_team = home_team if home_qualified else away_team
            analysis_parts.append(f"""
üéØ **AN√ÅLISE DO JOGO:**
‚Ä¢ **{qualified_team}:** Qualificada ‚úÖ
‚Ä¢ **Oportunidade:** BOA para Over 0.5  
‚Ä¢ **Confian√ßa:** ALTA
            """)
        else:
            analysis_parts.append(f"""
üéØ **AN√ÅLISE DO JOGO:**
‚Ä¢ **Status:** Nenhuma qualificada ‚ùå
‚Ä¢ **Motivo:** Ambas >7% de 0x0 hist√≥rico
‚Ä¢ **Recomenda√ß√£o:** Evitar este jogo
            """)
        
        return "\n".join(analysis_parts)

    async def daily_reset(self, context: ContextTypes.DEFAULT_TYPE):
        """Reset di√°rio do sistema"""
        logger.info("üîÑ Executando reset di√°rio do sistema...")
        
        # Limpar jogos detectados do dia anterior
        self.detected_games.clear()
        self.sent_alerts.clear()
        
        # Enviar resumo di√°rio para usu√°rios monitorados
        if self.monitored_users:
            daily_summary = f"""
üåÖ **BOM DIA! RESET DI√ÅRIO EXECUTADO**

ü§ñ **Sistema atualizado:**
‚úÖ Cache de jogos limpo
‚úÖ Alertas resetados  
‚úÖ Monitoramento ativo para hoje

üìä **Usu√°rios monitorados:** {len(self.monitored_users)}
üîç **Verifica√ß√µes:** A cada 5 minutos
üéØ **Equipes:** {len(self.teams_data)} cadastradas

üí° **Comandos √∫teis hoje:**
‚Ä¢ `/jogos_hoje` - Jogos detectados
‚Ä¢ `/pause_alertas` - Pausar temporariamente
‚Ä¢ `/status_auto` - Status do sistema
            """
            
            for user_id in self.monitored_users:
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=daily_summary,
                        parse_mode='Markdown'
                    )
                except:
                    pass  # Ignorar erros de usu√°rios que bloquearam
        
        logger.info("‚úÖ Reset di√°rio conclu√≠do")

    def get_cash_out_recommendation(self, team_name: str) -> Dict:
        """Sistema Cash Out (mantido da vers√£o anterior)"""
        if team_name not in self.teams_data:
            return {"error": "Equipe n√£o encontrada"}
            
        team_info = self.teams_data[team_name]
        zero_percent = team_info["zero_percent"]
        tier = team_info["tier"]
        
        if tier == "elite":
            return {
                "recommendation": "DEIXAR_CORRER",
                "confidence": "ALTA",
                "reason": f"Equipe elite com apenas {zero_percent}% de 0x0 hist√≥rico",
                "action": "üü¢ Aguardar at√© o fim - Baix√≠ssimo risco",
                "risk_level": "BAIXO"
            }
        elif tier == "premium":
            return {
                "recommendation": "DEIXAR_CORRER", 
                "confidence": "M√âDIA-ALTA",
                "reason": f"Equipe premium com {zero_percent}% de 0x0 hist√≥rico",
                "action": "üü° Aguardar at√© o fim - Risco controlado",
                "risk_level": "M√âDIO"
            }
        else:  # standard
            return {
                "recommendation": "CASH_OUT_80",
                "confidence": "M√âDIA",
                "reason": f"Equipe pr√≥xima ao limite com {zero_percent}% de 0x0",
                "action": "üü† Cash Out aos 80min - Risco elevado", 
                "risk_level": "ALTO"
            }

    # ========== COMANDOS AUTOM√ÅTICOS ==========
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /start com op√ß√µes autom√°ticas"""
        welcome_text = """
üöÄ **Bot Inteligente de Monitoramento - SISTEMA AUTOM√ÅTICO**
üìä **GLOBAL ZERO TRACKING com Detec√ß√£o Autom√°tica**

ü§ñ **FUNCIONALIDADES AUTOM√ÅTICAS:**
‚úÖ Detec√ß√£o autom√°tica de jogos das suas equipes
‚úÖ Alertas autom√°ticos para oportunidades  
‚úÖ Monitoramento cont√≠nuo de fixtures
‚úÖ Sistema Cash Out integrado
‚úÖ Reset di√°rio autom√°tico

üåç **COBERTURA:** 102 equipes, 6 continentes, ‚â§7% de 0x0

‚ö° **COMANDOS AUTOM√ÅTICOS:**
‚Ä¢ `/ativar_alertas` - üîî Receber alertas autom√°ticos
‚Ä¢ `/jogos_hoje` - üìÖ Jogos detectados hoje
‚Ä¢ `/status_auto` - üìä Status do sistema autom√°tico
‚Ä¢ `/pausar_alertas` - ‚è∏Ô∏è Pausar temporariamente

üìã **COMANDOS MANUAIS:**
‚Ä¢ `/equipes` - Lista todas as equipes
‚Ä¢ `/analise [equipe]` - An√°lise completa
‚Ä¢ `/oportunidades` - Equipes "vem de um 0x0"

üéØ **Para come√ßar com sistema autom√°tico:**
Digite `/ativar_alertas` e receba alertas autom√°ticos! ‚öΩ
        """
        
        await update.message.reply_text(welcome_text, parse_mode='Markdown')

    async def activate_alerts_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ativa alertas autom√°ticos para o usu√°rio"""
        user_id = update.effective_user.id
        
        if user_id in self.monitored_users:
            await update.message.reply_text(
                "‚úÖ **Alertas j√° est√£o ATIVADOS!**\n\n"
                "üîî Voc√™ receber√° alertas autom√°ticos para:\n"
                "‚Ä¢ Jogos das 102 equipes cadastradas\n"
                "‚Ä¢ Oportunidades de aproxima√ß√£o √† m√©dia\n"
                "‚Ä¢ Recomenda√ß√µes Cash Out\n\n"
                "‚è∏Ô∏è Use `/pausar_alertas` para pausar\n"
                "üìä Use `/status_auto` para ver status",
                parse_mode='Markdown'
            )
        else:
            self.monitored_users.add(user_id)
            await update.message.reply_text(
                "üîî **ALERTAS AUTOM√ÅTICOS ATIVADOS!**\n\n"
                "‚úÖ **Voc√™ agora receber√°:**\n"
                "‚Ä¢ Jogos detectados automaticamente\n"
                "‚Ä¢ An√°lises Cash Out em tempo real\n"
                "‚Ä¢ Oportunidades de aproxima√ß√£o √† m√©dia\n"
                "‚Ä¢ Reset di√°rio com resumo\n\n"
                "ü§ñ **Sistema funcionando:**\n"
                "‚Ä¢ Verifica√ß√µes a cada 5 minutos\n"
                "‚Ä¢ Monitoramento de 102 equipes\n"
                "‚Ä¢ Cobertura de 6 continentes\n\n"
                "üìä Digite `/status_auto` para ver detalhes",
                parse_mode='Markdown'
            )
            logger.info(f"üîî Usu√°rio {user_id} ativou alertas autom√°ticos")

    async def pause_alerts_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Pausa/desativa alertas autom√°ticos"""
        user_id = update.effective_user.id
        
        if user_id in self.monitored_users:
            self.monitored_users.remove(user_id)
            await update.message.reply_text(
                "‚è∏Ô∏è **ALERTAS PAUSADOS!**\n\n"
                "‚ùå Voc√™ n√£o receber√° mais alertas autom√°ticos\n"
                "üîÑ Para reativar: `/ativar_alertas`\n"
                "üìã Comandos manuais continuam funcionando\n\n"
                "üí° **Comandos dispon√≠veis:**\n"
                "‚Ä¢ `/jogos_hoje` - Ver jogos detectados\n"
                "‚Ä¢ `/analise [equipe]` - An√°lise manual\n"
                "‚Ä¢ `/equipes` - Lista completa",
                parse_mode='Markdown'
            )
            logger.info(f"‚è∏Ô∏è Usu√°rio {user_id} pausou alertas autom√°ticos")
        else:
            await update.message.reply_text(
                "‚ÑπÔ∏è **Alertas j√° est√£o pausados**\n\n"
                "üîî Para ativar: `/ativar_alertas`\n"
                "üìä Para ver status: `/status_auto`",
                parse_mode='Markdown'
            )

    async def games_today_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostra jogos detectados hoje"""
        if not self.detected_games:
            await update.message.reply_text(
                "üìÖ **JOGOS HOJE**\n\n"
                "‚ùå Nenhum jogo detectado ainda\n\n"
                "üîç **Sistema verificando:**\n"
                "‚Ä¢ A cada 5 minutos\n"
                "‚Ä¢ 102 equipes cadastradas\n"
                "‚Ä¢ M√∫ltiplas competi√ß√µes\n\n"
                "üîî Ative alertas: `/ativar_alertas`",
                parse_mode='Markdown'
            )
            return
        
        response = f"üìÖ **JOGOS DETECTADOS HOJE** ({len(self.detected_games)} jogos)\n\n"
        
        for game_key, game_data in self.detected_games.items():
            home_team = game_data["home_team"]
            away_team = game_data["away_team"]
            kickoff = game_data["kickoff"]
            competition = game_data["competition"]
            
            # Status das equipes
            home_status = "‚úÖ" if game_data["home_in_db"] else "‚ùå"
            away_status = "‚úÖ" if game_data["away_in_db"] else "‚ùå"
            
            response += f"‚öΩ **{home_team}** {home_status} vs **{away_team}** {away_status}\n"
            response += f"üïí {kickoff} | üèÜ {competition}\n"
            
            # An√°lise r√°pida
            if home_team in self.teams_data:
                home_percent = self.teams_data[home_team]["zero_percent"]
                response += f"üè† {home_team}: {home_percent}% de 0x0\n"
            
            if away_team in self.teams_data:
                away_percent = self.teams_data[away_team]["zero_percent"] 
                response += f"‚úàÔ∏è {away_team}: {away_percent}% de 0x0\n"
            
            response += "\n"
        
        response += "üí° **An√°lise detalhada:** `/analise [nome da equipe]`"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def auto_status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Status do sistema autom√°tico"""
        user_id = update.effective_user.id
        alerts_status = "üîî ATIVADOS" if user_id in self.monitored_users else "‚è∏Ô∏è PAUSADOS"
        
        next_check = "Em at√© 5 minutos"  # Aproximado
        
        response = f"""
ü§ñ **STATUS DO SISTEMA AUTOM√ÅTICO**

üìä **Seu Status:**
‚Ä¢ **Alertas:** {alerts_status}
‚Ä¢ **Pr√≥xima verifica√ß√£o:** {next_check}

üìà **Estat√≠sticas Gerais:**
‚Ä¢ **Usu√°rios monitorados:** {len(self.monitored_users)}
‚Ä¢ **Jogos detectados hoje:** {len(self.detected_games)}
‚Ä¢ **Equipes cadastradas:** {len(self.teams_data)}
‚Ä¢ **Continentes:** 6 (Europa, Am√©ricas, √Åsia, √Åfrica, Oceania)

‚öôÔ∏è **Configura√ß√µes:**
‚Ä¢ **Intervalo de verifica√ß√£o:** 5 minutos
‚Ä¢ **Reset di√°rio:** 06:00 
‚Ä¢ **Competi√ß√µes monitoradas:** Todas as principais

üîÑ **√öltima verifica√ß√£o:** Autom√°tica e cont√≠nua
        """
        
        if self.detected_games:
            response += f"\n\nüéØ **Jogos hoje:** `/jogos_hoje`"
        
        if user_id not in self.monitored_users:
            response += f"\n\nüîî **Ativar alertas:** `/ativar_alertas`"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    # ========== COMANDOS MANUAIS (mantidos da vers√£o anterior) ==========
    
    async def teams_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Lista todas as equipes (vers√£o anterior mantida)"""
        # Organizar por continente
        continents = {}
        for team, info in self.teams_data.items():
            continent = info["continent"]
            if continent not in continents:
                continents[continent] = []
            continents[continent].append((team, info))
        
        response = f"üåç **EQUIPES MONITORADAS AUTOMATICAMENTE** ({len(self.teams_data)} total)\n\n"
        
        for continent, teams in continents.items():
            response += f"üåü **{continent.upper()}** ({len(teams)} equipes)\n"
            
            # Ordenar por % de 0x0
            teams.sort(key=lambda x: x[1]["zero_percent"])
            
            for team, info in teams[:5]:  # Mostrar apenas top 5 por continente
                tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
                response += f"{tier_emoji[info['tier']]} {team} - {info['zero_percent']}%\n"
            
            if len(teams) > 5:
                response += f"... e mais {len(teams)-5} equipes\n"
            
            response += "\n"
        
        response += "\nü§ñ **Sistema autom√°tico detecta jogos dessas equipes!**\n"
        response += "üîî **Ativar alertas:** `/ativar_alertas`"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def analysis_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """An√°lise completa (mantida da vers√£o anterior + melhorias autom√°ticas)"""
        if not context.args:
            await update.message.reply_text(
                "‚ùå **Uso:** `/analise [nome da equipe]`\n"
                "üí° **Exemplo:** `/analise FC Porto`\n"
                "üìã **Equipes:** `/equipes`\n"
                "ü§ñ **Autom√°tico:** `/ativar_alertas`",
                parse_mode='Markdown'
            )
            return
        
        team_name = " ".join(context.args)
        
        # Busca flex√≠vel
        found_team = None
        for team in self.teams_data.keys():
            if team_name.lower() in team.lower() or team.lower() in team_name.lower():
                found_team = team
                break
        
        if not found_team:
            await update.message.reply_text(
                f"‚ùå **'{team_name}' n√£o encontrada**\n"
                f"üìã `/equipes` para ver dispon√≠veis\n"
                f"ü§ñ Sistema autom√°tico monitora apenas equipes cadastradas",
                parse_mode='Markdown'
            )
            return
        
        # An√°lise completa
        team_info = self.teams_data[found_team]
        cash_out = self.get_cash_out_recommendation(found_team)
        
        # Verificar se tem jogo hoje
        game_today = None
        for game_data in self.detected_games.values():
            if found_team in [game_data["home_team"], game_data["away_team"]]:
                game_today = game_data
                break
        
        tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
        
        response = f"""
üèÜ **{found_team.upper()}** {tier_emoji[team_info['tier']]}

üìä **ESTAT√çSTICAS:**
‚Ä¢ **Liga:** {team_info['league']} ({team_info['continent']})
‚Ä¢ **% de 0x0:** {team_info['zero_percent']}% (√∫ltimos 3 anos)
‚Ä¢ **Tier:** {team_info['tier'].capitalize()}

üí∞ **CASH OUT:**
‚Ä¢ **A√ß√£o:** {cash_out['recommendation']}
‚Ä¢ **Confian√ßa:** {cash_out['confidence']}
‚Ä¢ **Decis√£o:** {cash_out['action']}
‚Ä¢ **Motivo:** {cash_out['reason']}
        """
        
        if game_today:
            opponent = game_today["away_team"] if found_team == game_today["home_team"] else game_today["home_team"]
            home_away = "üè† Casa" if found_team == game_today["home_team"] else "‚úàÔ∏è Fora"
            
            response += f"""

üö® **JOGO HOJE DETECTADO!**
‚Ä¢ **Advers√°rio:** {opponent}
‚Ä¢ **Hor√°rio:** {game_today['kickoff']}
‚Ä¢ **Local:** {home_away}
‚Ä¢ **Competi√ß√£o:** {game_today['competition']}
‚Ä¢ **Status:** Monitoramento autom√°tico ativo ‚úÖ
            """
        else:
            response += f"""

üìÖ **PR√ìXIMOS JOGOS:**
‚Ä¢ Nenhum jogo detectado hoje
‚Ä¢ Sistema verifica automaticamente a cada 5min
‚Ä¢ Ative alertas: `/ativar_alertas`
            """
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipulador de erros"""
        logger.error(f"Erro: {context.error}")
        
        if update and update.message:
            await update.message.reply_text(
                "‚ùå **Erro interno**\n"
                "üîÑ Tente novamente\n"  
                "ü§ñ Sistema autom√°tico continua funcionando",
                parse_mode='Markdown'
            )

def main():
    """Fun√ß√£o principal com sistema autom√°tico completo"""
    
    TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    if not TOKEN:
        logger.error("‚ùå TELEGRAM_BOT_TOKEN n√£o encontrado!")
        sys.exit(1)
    
    logger.info("üöÄ Iniciando Bot Autom√°tico de Monitoramento...")
    
    # Criar inst√¢ncia do bot autom√°tico
    bot = AutomaticFootballBot()
    
    # Criar aplica√ß√£o
    application = Application.builder().token(TOKEN).build()
    
    # Registrar comandos autom√°ticos
    application.add_handler(CommandHandler("start", bot.start_command))
    application.add_handler(CommandHandler("ativar_alertas", bot.activate_alerts_command))
    application.add_handler(CommandHandler("pausar_alertas", bot.pause_alerts_command))
    application.add_handler(CommandHandler("jogos_hoje", bot.games_today_command))
    application.add_handler(CommandHandler("status_auto", bot.auto_status_command))
    
    # Comandos manuais (mantidos)
    application.add_handler(CommandHandler("equipes", bot.teams_command))
    application.add_handler(CommandHandler("analise", bot.analysis_command))
    
    # Handler de erro
    application.add_error_handler(bot.error_handler)
    
    # Iniciar sistema autom√°tico ap√≥s aplica√ß√£o estar pronta
    async def post_init(application):
        await bot.start_automatic_monitoring(application.bot_data)
    
    application.post_init = post_init
    
    logger.info(f"‚úÖ Bot autom√°tico carregado - {len(bot.teams_data)} equipes!")
    logger.info("ü§ñ Sistema de monitoramento autom√°tico iniciando...")
    
    # Executar com polling
    try:
        application.run_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True,
            poll_interval=1.0,
            timeout=10
        )
    except Exception as e:
        logger.error(f"‚ùå Erro: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
