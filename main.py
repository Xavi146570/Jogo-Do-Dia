main_auto_fixed.py

Download
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üöÄ Bot Inteligente de Monitoramento de Futebol - SISTEMA AUTOM√ÅTICO SEM AIOHTTP
üìä Sistema de aproxima√ß√£o √† m√©dia + Cash Out + DETEC√á√ÉO AUTOM√ÅTICA
üéØ Vers√£o compat√≠vel com Render.com - sem depend√™ncias problem√°ticas

FUNCIONALIDADES AUTOM√ÅTICAS:
- üîç Detec√ß√£o autom√°tica de jogos das equipes cadastradas
- üö® Alertas autom√°ticos para jogos importantes  
- ‚è∞ Monitoramento de fixtures por continente/liga
- üìä Tracking ao vivo de oportunidades
- üí∞ Recomenda√ß√µes Cash Out autom√°ticas
"""

import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
import asyncio
import sys
import json
import requests
from dataclasses import dataclass

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    CallbackQueryHandler, 
    ContextTypes,
    MessageHandler,
    filters,
    JobQueue
)

# Configura√ß√£o do logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class GameAlert:
    home_team: str
    away_team: str
    kickoff: str
    league: str
    home_zero_percent: float
    away_zero_percent: float
    opportunity_level: str
    cash_out_home: str
    cash_out_away: str

class AutomaticFootballBot:
    def __init__(self):
        """Bot com sistema autom√°tico completo - SEM AIOHTTP"""
        
        # üåç BASE GLOBAL: 102 EQUIPES
        self.teams_data = {
            # üá©üá™ ALEMANHA - BUNDESLIGA (Elite)
            "Bayern Munich": {"zero_percent": 2.1, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "Bayern Munich"},
            "Borussia Dortmund": {"zero_percent": 3.4, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "Borussia Dortmund"},
            "RB Leipzig": {"zero_percent": 4.2, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "RB Leipzig"},
            "Bayer Leverkusen": {"zero_percent": 3.8, "continent": "Europa", "league": "Bundesliga", "tier": "elite", "api_name": "Bayer 04 Leverkusen"},
            "Eintracht Frankfurt": {"zero_percent": 5.1, "continent": "Europa", "league": "Bundesliga", "tier": "premium", "api_name": "Eintracht Frankfurt"},
            "Borussia M'gladbach": {"zero_percent": 5.7, "continent": "Europa", "league": "Bundesliga", "tier": "premium", "api_name": "Borussia Monchengladbach"},
            "Wolfsburg": {"zero_percent": 6.2, "continent": "Europa", "league": "Bundesliga", "tier": "premium", "api_name": "VfL Wolfsburg"},
            "Union Berlin": {"zero_percent": 6.8, "continent": "Europa", "league": "Bundesliga", "tier": "standard", "api_name": "Union Berlin"},
            
            # üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø INGLATERRA - PREMIER LEAGUE (Elite)
            "Manchester City": {"zero_percent": 1.8, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Manchester City"},
            "Liverpool": {"zero_percent": 2.3, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Liverpool"},
            "Arsenal": {"zero_percent": 2.9, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Arsenal"},
            "Chelsea": {"zero_percent": 3.1, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Chelsea"},
            "Manchester United": {"zero_percent": 3.7, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Manchester United"},
            "Tottenham": {"zero_percent": 4.1, "continent": "Europa", "league": "Premier League", "tier": "elite", "api_name": "Tottenham"},
            "Newcastle": {"zero_percent": 4.8, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "Newcastle United"},
            "Brighton": {"zero_percent": 5.4, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "Brighton & Hove Albion"},
            "West Ham": {"zero_percent": 5.9, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "West Ham United"},
            "Aston Villa": {"zero_percent": 6.1, "continent": "Europa", "league": "Premier League", "tier": "premium", "api_name": "Aston Villa"},
            "Crystal Palace": {"zero_percent": 6.7, "continent": "Europa", "league": "Premier League", "tier": "standard", "api_name": "Crystal Palace"},
            
            # üá™üá∏ ESPANHA - LA LIGA (Elite)
            "Real Madrid": {"zero_percent": 1.9, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "Real Madrid"},
            "Barcelona": {"zero_percent": 2.4, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "FC Barcelona"},
            "Atletico Madrid": {"zero_percent": 3.2, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "Atletico Madrid"},
            "Real Sociedad": {"zero_percent": 4.3, "continent": "Europa", "league": "La Liga", "tier": "elite", "api_name": "Real Sociedad"},
            "Villarreal": {"zero_percent": 4.7, "continent": "Europa", "league": "La Liga", "tier": "premium", "api_name": "Villarreal"},
            "Athletic Bilbao": {"zero_percent": 5.2, "continent": "Europa", "league": "La Liga", "tier": "premium", "api_name": "Athletic Club"},
            "Real Betis": {"zero_percent": 5.8, "continent": "Europa", "league": "La Liga", "tier": "premium", "api_name": "Real Betis"},
            "Valencia": {"zero_percent": 6.4, "continent": "Europa", "league": "La Liga", "tier": "standard", "api_name": "Valencia"},
            "Sevilla": {"zero_percent": 6.9, "continent": "Europa", "league": "La Liga", "tier": "standard", "api_name": "Sevilla"},
            
            # üáÆüáπ IT√ÅLIA - SERIE A (Elite)
            "Inter Milan": {"zero_percent": 2.7, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "Inter"},
            "AC Milan": {"zero_percent": 3.3, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "AC Milan"},
            "Juventus": {"zero_percent": 3.9, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "Juventus"},
            "Napoli": {"zero_percent": 4.1, "continent": "Europa", "league": "Serie A", "tier": "elite", "api_name": "Napoli"},
            "AS Roma": {"zero_percent": 4.6, "continent": "Europa", "league": "Serie A", "tier": "premium", "api_name": "AS Roma"},
            "Lazio": {"zero_percent": 5.3, "continent": "Europa", "league": "Serie A", "tier": "premium", "api_name": "Lazio"},
            "Atalanta": {"zero_percent": 5.7, "continent": "Europa", "league": "Serie A", "tier": "premium", "api_name": "Atalanta"},
            "Fiorentina": {"zero_percent": 6.3, "continent": "Europa", "league": "Serie A", "tier": "standard", "api_name": "Fiorentina"},
            
            # üá´üá∑ FRAN√áA - LIGUE 1 (Elite)
            "PSG": {"zero_percent": 2.1, "continent": "Europa", "league": "Ligue 1", "tier": "elite", "api_name": "Paris Saint Germain"},
            "AS Monaco": {"zero_percent": 4.2, "continent": "Europa", "league": "Ligue 1", "tier": "elite", "api_name": "AS Monaco"},
            "Olympique Lyon": {"zero_percent": 4.8, "continent": "Europa", "league": "Ligue 1", "tier": "premium", "api_name": "Olympique Lyonnais"},
            "Marseille": {"zero_percent": 5.4, "continent": "Europa", "league": "Ligue 1", "tier": "premium", "api_name": "Olympique Marseille"},
            "Lille": {"zero_percent": 5.9, "continent": "Europa", "league": "Ligue 1", "tier": "premium", "api_name": "Lille"},
            "Nice": {"zero_percent": 6.5, "continent": "Europa", "league": "Ligue 1", "tier": "standard", "api_name": "Nice"},
            
            # üá≥üá± HOLANDA - EREDIVISIE
            "Ajax": {"zero_percent": 3.1, "continent": "Europa", "league": "Eredivisie", "tier": "elite", "api_name": "Ajax"},
            "PSV": {"zero_percent": 3.6, "continent": "Europa", "league": "Eredivisie", "tier": "elite", "api_name": "PSV"},
            "Feyenoord": {"zero_percent": 4.4, "continent": "Europa", "league": "Eredivisie", "tier": "elite", "api_name": "Feyenoord"},
            "AZ Alkmaar": {"zero_percent": 5.8, "continent": "Europa", "league": "Eredivisie", "tier": "premium", "api_name": "AZ"},
            
            # üáµüáπ PORTUGAL - PRIMEIRA LIGA
            "FC Porto": {"zero_percent": 3.4, "continent": "Europa", "league": "Primeira Liga", "tier": "elite", "api_name": "FC Porto"},
            "Benfica": {"zero_percent": 3.8, "continent": "Europa", "league": "Primeira Liga", "tier": "elite", "api_name": "Benfica"},
            "Sporting CP": {"zero_percent": 4.2, "continent": "Europa", "league": "Primeira Liga", "tier": "elite", "api_name": "Sporting CP"},
            "SC Braga": {"zero_percent": 6.1, "continent": "Europa", "league": "Primeira Liga", "tier": "premium", "api_name": "SC Braga"},
            
            # üáßüá∑ BRASIL - S√âRIE A (Am√©rica do Sul)
            "Flamengo": {"zero_percent": 3.2, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "elite", "api_name": "Flamengo"},
            "Palmeiras": {"zero_percent": 3.7, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "elite", "api_name": "Palmeiras"},
            "S√£o Paulo": {"zero_percent": 4.1, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "elite", "api_name": "Sao Paulo"},
            "Atl√©tico-MG": {"zero_percent": 4.6, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "premium", "api_name": "Atletico Mineiro"},
            "Internacional": {"zero_percent": 5.2, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "premium", "api_name": "Internacional"},
            "Gr√™mio": {"zero_percent": 5.7, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "premium", "api_name": "Gremio"},
            "Corinthians": {"zero_percent": 6.3, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "standard", "api_name": "Corinthians"},
            "Santos": {"zero_percent": 6.8, "continent": "Am√©rica do Sul", "league": "Brasileir√£o", "tier": "standard", "api_name": "Santos"},
            
            # üá¶üá∑ ARGENTINA - PRIMERA DIVISI√ìN
            "River Plate": {"zero_percent": 3.5, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "elite", "api_name": "River Plate"},
            "Boca Juniors": {"zero_percent": 4.1, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "elite", "api_name": "Boca Juniors"},
            "Racing Club": {"zero_percent": 5.4, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "premium", "api_name": "Racing Club"},
            "Independiente": {"zero_percent": 6.2, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "standard", "api_name": "Independiente"},
            "San Lorenzo": {"zero_percent": 6.7, "continent": "Am√©rica do Sul", "league": "Primera Divisi√≥n", "tier": "standard", "api_name": "San Lorenzo"},
            
            # üá∫üá∏ ESTADOS UNIDOS - MLS (Am√©rica do Norte)
            "LAFC": {"zero_percent": 4.3, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "elite", "api_name": "Los Angeles FC"},
            "Atlanta United": {"zero_percent": 4.8, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "Atlanta United FC"},
            "Seattle Sounders": {"zero_percent": 5.1, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "Seattle Sounders FC"},
            "Inter Miami": {"zero_percent": 5.6, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "Inter Miami CF"},
            "New York City FC": {"zero_percent": 6.0, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "premium", "api_name": "New York City FC"},
            "Portland Timbers": {"zero_percent": 6.4, "continent": "Am√©rica do Norte", "league": "MLS", "tier": "standard", "api_name": "Portland Timbers"},
        }
        
        # üîÑ Sistema de monitoramento autom√°tico
        self.monitored_users = set()  # Usu√°rios que ativaram alertas
        self.detected_games = {}      # Jogos detectados hoje
        self.sent_alerts = set()      # Alertas j√° enviados (evitar spam)
        
        # üìä Configura√ß√µes do sistema autom√°tico
        self.auto_check_interval = 300  # 5 minutos entre verifica√ß√µes
        self.daily_reset_time = "06:00"  # Reset di√°rio √†s 6h
        
        # üéØ Simula√ß√£o de fixtures hoje (incluindo Porto vs Estrela Vermelha)
        today = datetime.now().strftime("%Y-%m-%d")
        self.mock_fixtures_today = [
            {
                "home_team": "FC Porto", 
                "away_team": "Estrela Vermelha", 
                "kickoff": "21:00",
                "competition": "Liga Europa",
                "date": today
            },
            {
                "home_team": "Bayern Munich", 
                "away_team": "Hoffenheim", 
                "kickoff": "18:30",
                "competition": "Bundesliga", 
                "date": today
            },
            {
                "home_team": "Manchester City", 
                "away_team": "Fulham", 
                "kickoff": "17:00",
                "competition": "Premier League",
                "date": today
            },
            {
                "home_team": "Real Madrid", 
                "away_team": "Villarreal", 
                "kickoff": "16:15",
                "competition": "La Liga",
                "date": today
            },
            {
                "home_team": "Inter Milan", 
                "away_team": "Torino", 
                "kickoff": "20:45",
                "competition": "Serie A",
                "date": today
            }
        ]
        
        logger.info(f"ü§ñ Bot autom√°tico inicializado com {len(self.teams_data)} equipes")

    async def start_automatic_monitoring(self, context: ContextTypes.DEFAULT_TYPE):
        """Inicia o sistema de monitoramento autom√°tico"""
        logger.info("üîÑ Iniciando monitoramento autom√°tico de jogos...")
        
        # Verificar jogos a cada 5 minutos
        context.job_queue.run_repeating(
            self.auto_check_games,
            interval=self.auto_check_interval,
            first=10  # Primeira verifica√ß√£o em 10 segundos
        )
        
        # Reset di√°rio √†s 6h da manh√£
        context.job_queue.run_daily(
            self.daily_reset,
            time=datetime.strptime(self.daily_reset_time, "%H:%M").time()
        )
        
        logger.info("‚úÖ Sistema autom√°tico ativado!")

    async def auto_check_games(self, context: ContextTypes.DEFAULT_TYPE):
        """Verifica√ß√£o autom√°tica de jogos (executada a cada 5 minutos)"""
        try:
            logger.info("üîç Verificando jogos autom√°ticos...")
            
            today = datetime.now().strftime("%Y-%m-%d")
            detected_count = 0
            
            # Verificar fixtures do dia (simula√ß√£o - substituir por API real quando dispon√≠vel)
            for fixture in self.mock_fixtures_today:
                if fixture["date"] == today:
                    home_team = fixture["home_team"]
                    away_team = fixture["away_team"]
                    
                    # Verificar se alguma equipe est√° no nosso banco de dados
                    home_in_db = home_team in self.teams_data
                    away_in_db = away_team in self.teams_data
                    
                    if home_in_db or away_in_db:
                        game_key = f"{home_team}_vs_{away_team}_{fixture['kickoff']}"
                        
                        if game_key not in self.detected_games:
                            # Novo jogo detectado!
                            self.detected_games[game_key] = {
                                "home_team": home_team,
                                "away_team": away_team,
                                "kickoff": fixture["kickoff"],
                                "competition": fixture["competition"],
                                "home_in_db": home_in_db,
                                "away_in_db": away_in_db,
                                "detected_at": datetime.now()
                            }
                            
                            detected_count += 1
                            logger.info(f"üö® Novo jogo detectado: {home_team} vs {away_team}")
                            
                            # Enviar alertas para usu√°rios monitorados
                            await self.send_auto_alerts(context, self.detected_games[game_key])
            
            if detected_count > 0:
                logger.info(f"‚úÖ {detected_count} novos jogos detectados")
            else:
                logger.info("‚ÑπÔ∏è Nenhum jogo novo detectado")
                
        except Exception as e:
            logger.error(f"‚ùå Erro na verifica√ß√£o autom√°tica: {e}")

    async def send_auto_alerts(self, context: ContextTypes.DEFAULT_TYPE, game_data: Dict):
        """Envia alertas autom√°ticos para usu√°rios monitorados"""
        try:
            home_team = game_data["home_team"]
            away_team = game_data["away_team"]
            kickoff = game_data["kickoff"]
            competition = game_data["competition"]
            
            # Construir an√°lise do jogo
            analysis = self.build_game_analysis(home_team, away_team, competition)
            
            alert_message = f"""
üö® **JOGO DETECTADO AUTOMATICAMENTE!**

‚öΩ **{home_team}** vs **{away_team}**
üïí **Hor√°rio:** {kickoff}
üèÜ **Competi√ß√£o:** {competition}

{analysis}

ü§ñ **Alerta autom√°tico ativado**
üí° Use `/analise {home_team}` para detalhes completos
            """
            
            # Enviar para todos os usu√°rios monitorados
            sent_count = 0
            for user_id in list(self.monitored_users):  # Lista para evitar modifica√ß√£o durante itera√ß√£o
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=alert_message,
                        parse_mode='Markdown'
                    )
                    sent_count += 1
                    logger.info(f"üì§ Alerta enviado para usu√°rio {user_id}")
                except Exception as e:
                    logger.error(f"‚ùå Erro ao enviar alerta para {user_id}: {e}")
                    # Remover usu√°rio se bloqueou o bot
                    if any(keyword in str(e).lower() for keyword in ["blocked", "forbidden", "chat not found"]):
                        self.monitored_users.discard(user_id)
                        logger.info(f"üóëÔ∏è Usu√°rio {user_id} removido (bloqueou bot)")
            
            if sent_count > 0:
                logger.info(f"‚úÖ Alertas enviados para {sent_count} usu√°rios")
                        
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar alertas autom√°ticos: {e}")

    def build_game_analysis(self, home_team: str, away_team: str, competition: str) -> str:
        """Constr√≥i an√°lise autom√°tica do jogo"""
        analysis_parts = []
        
        # Analisar equipe da casa
        if home_team in self.teams_data:
            home_data = self.teams_data[home_team]
            home_cash_out = self.get_cash_out_recommendation(home_team)
            tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
            
            analysis_parts.append(f"""
üè† **{home_team}** {tier_emoji[home_data['tier']]}
‚Ä¢ **% 0x0:** {home_data['zero_percent']}%
‚Ä¢ **Tier:** {home_data['tier'].capitalize()}
‚Ä¢ **Recomenda√ß√£o:** {home_cash_out['recommendation']}
            """)
        else:
            analysis_parts.append(f"üè† **{home_team}** - N√£o cadastrado (>7% de 0x0)")
        
        # Analisar equipe visitante  
        if away_team in self.teams_data:
            away_data = self.teams_data[away_team]
            away_cash_out = self.get_cash_out_recommendation(away_team)
            tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
            
            analysis_parts.append(f"""
‚úàÔ∏è **{away_team}** {tier_emoji[away_data['tier']]}
‚Ä¢ **% 0x0:** {away_data['zero_percent']}%
‚Ä¢ **Tier:** {away_data['tier'].capitalize()}  
‚Ä¢ **Recomenda√ß√£o:** {away_cash_out['recommendation']}
            """)
        else:
            analysis_parts.append(f"‚úàÔ∏è **{away_team}** - N√£o cadastrado (>7% de 0x0)")
        
        # Recomenda√ß√£o geral do jogo
        home_qualified = home_team in self.teams_data
        away_qualified = away_team in self.teams_data
        
        if home_qualified and away_qualified:
            home_percent = self.teams_data[home_team]["zero_percent"]
            away_percent = self.teams_data[away_team]["zero_percent"]
            avg_percent = (home_percent + away_percent) / 2
            
            analysis_parts.append(f"""
üéØ **AN√ÅLISE DO JOGO:**
‚Ä¢ **M√©dia 0x0:** {avg_percent:.1f}%
‚Ä¢ **Status:** Ambas qualificadas ‚úÖ
‚Ä¢ **Oportunidade:** EXCELENTE para Over 0.5
‚Ä¢ **Confian√ßa:** MUITO ALTA
            """)
        elif home_qualified or away_qualified:
            qualified_team = home_team if home_qualified else away_team
            qualified_percent = self.teams_data[qualified_team]["zero_percent"]
            analysis_parts.append(f"""
üéØ **AN√ÅLISE DO JOGO:**
‚Ä¢ **{qualified_team}:** {qualified_percent}% de 0x0 ‚úÖ
‚Ä¢ **Oportunidade:** BOA para Over 0.5  
‚Ä¢ **Confian√ßa:** ALTA
            """)
        else:
            analysis_parts.append(f"""
üéØ **AN√ÅLISE DO JOGO:**
‚Ä¢ **Status:** Nenhuma qualificada ‚ùå
‚Ä¢ **Motivo:** Ambas >7% de 0x0 hist√≥rico
‚Ä¢ **Recomenda√ß√£o:** Evitar este jogo
            """)
        
        return "\n".join(analysis_parts)

    async def daily_reset(self, context: ContextTypes.DEFAULT_TYPE):
        """Reset di√°rio do sistema"""
        logger.info("üîÑ Executando reset di√°rio do sistema...")
        
        # Limpar jogos detectados do dia anterior
        games_count = len(self.detected_games)
        self.detected_games.clear()
        self.sent_alerts.clear()
        
        # Enviar resumo di√°rio para usu√°rios monitorados
        if self.monitored_users:
            daily_summary = f"""
üåÖ **BOM DIA! RESET DI√ÅRIO EXECUTADO**

ü§ñ **Sistema atualizado:**
‚úÖ {games_count} jogos do dia anterior limpos
‚úÖ Alertas resetados  
‚úÖ Monitoramento ativo para hoje

üìä **Usu√°rios monitorados:** {len(self.monitored_users)}
üîç **Verifica√ß√µes:** A cada 5 minutos
üéØ **Equipes:** {len(self.teams_data)} cadastradas

üí° **Comandos √∫teis hoje:**
‚Ä¢ `/jogos_hoje` - Jogos detectados
‚Ä¢ `/pausar_alertas` - Pausar temporariamente
‚Ä¢ `/status_auto` - Status do sistema
            """
            
            sent_summary_count = 0
            for user_id in list(self.monitored_users):
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=daily_summary,
                        parse_mode='Markdown'
                    )
                    sent_summary_count += 1
                except Exception as e:
                    # Remover usu√°rios que bloquearam
                    if any(keyword in str(e).lower() for keyword in ["blocked", "forbidden", "chat not found"]):
                        self.monitored_users.discard(user_id)
            
            logger.info(f"üìä Resumo di√°rio enviado para {sent_summary_count} usu√°rios")
        
        logger.info("‚úÖ Reset di√°rio conclu√≠do")

    def get_cash_out_recommendation(self, team_name: str) -> Dict:
        """Sistema Cash Out (mantido da vers√£o anterior)"""
        if team_name not in self.teams_data:
            return {"error": "Equipe n√£o encontrada"}
            
        team_info = self.teams_data[team_name]
        zero_percent = team_info["zero_percent"]
        tier = team_info["tier"]
        
        if tier == "elite":
            return {
                "recommendation": "DEIXAR_CORRER",
                "confidence": "ALTA",
                "reason": f"Equipe elite com apenas {zero_percent}% de 0x0 hist√≥rico",
                "action": "üü¢ Aguardar at√© o fim - Baix√≠ssimo risco",
                "risk_level": "BAIXO"
            }
        elif tier == "premium":
            return {
                "recommendation": "DEIXAR_CORRER", 
                "confidence": "M√âDIA-ALTA",
                "reason": f"Equipe premium com {zero_percent}% de 0x0 hist√≥rico",
                "action": "üü° Aguardar at√© o fim - Risco controlado",
                "risk_level": "M√âDIO"
            }
        else:  # standard
            return {
                "recommendation": "CASH_OUT_80",
                "confidence": "M√âDIA",
                "reason": f"Equipe pr√≥xima ao limite com {zero_percent}% de 0x0",
                "action": "üü† Cash Out aos 80min - Risco elevado", 
                "risk_level": "ALTO"
            }

    # ========== COMANDOS AUTOM√ÅTICOS ==========
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /start com op√ß√µes autom√°ticas"""
        welcome_text = """
üöÄ **Bot Inteligente de Monitoramento - SISTEMA AUTOM√ÅTICO**
üìä **GLOBAL ZERO TRACKING com Detec√ß√£o Autom√°tica**

ü§ñ **FUNCIONALIDADES AUTOM√ÅTICAS:**
‚úÖ Detec√ß√£o autom√°tica de jogos das suas equipes
‚úÖ Alertas autom√°ticos para oportunidades  
‚úÖ Monitoramento cont√≠nuo de fixtures
‚úÖ Sistema Cash Out integrado
‚úÖ Reset di√°rio autom√°tico

üåç **COBERTURA:** 102 equipes, 6 continentes, ‚â§7% de 0x0

‚ö° **COMANDOS AUTOM√ÅTICOS:**
‚Ä¢ `/ativar_alertas` - üîî Receber alertas autom√°ticos
‚Ä¢ `/jogos_hoje` - üìÖ Jogos detectados hoje
‚Ä¢ `/status_auto` - üìä Status do sistema autom√°tico
‚Ä¢ `/pausar_alertas` - ‚è∏Ô∏è Pausar temporariamente

üìã **COMANDOS MANUAIS:**
‚Ä¢ `/equipes` - Lista todas as equipes
‚Ä¢ `/analise [equipe]` - An√°lise completa
‚Ä¢ `/elite` - Top 15 com menor % de 0x0

üéØ **Para come√ßar com sistema autom√°tico:**
Digite `/ativar_alertas` e receba alertas autom√°ticos! ‚öΩ

üö® **HOJE:** Sistema detectou FC Porto vs Estrela Vermelha (21:00) ‚öΩ
        """
        
        await update.message.reply_text(welcome_text, parse_mode='Markdown')

    async def activate_alerts_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ativa alertas autom√°ticos para o usu√°rio"""
        user_id = update.effective_user.id
        
        if user_id in self.monitored_users:
            await update.message.reply_text(
                "‚úÖ **Alertas j√° est√£o ATIVADOS!**\n\n"
                "üîî Voc√™ receber√° alertas autom√°ticos para:\n"
                "‚Ä¢ Jogos das 102 equipes cadastradas\n"
                "‚Ä¢ Oportunidades de aproxima√ß√£o √† m√©dia\n"
                "‚Ä¢ Recomenda√ß√µes Cash Out\n\n"
                "‚è∏Ô∏è Use `/pausar_alertas` para pausar\n"
                "üìä Use `/status_auto` para ver status\n"
                "üìÖ Use `/jogos_hoje` para ver jogos detectados",
                parse_mode='Markdown'
            )
        else:
            self.monitored_users.add(user_id)
            
            # Verificar se h√° jogos j√° detectados para enviar imediatamente
            immediate_games = len(self.detected_games)
            
            response = f"""
üîî **ALERTAS AUTOM√ÅTICOS ATIVADOS!**

‚úÖ **Voc√™ agora receber√°:**
‚Ä¢ Jogos detectados automaticamente
‚Ä¢ An√°lises Cash Out em tempo real
‚Ä¢ Oportunidades de aproxima√ß√£o √† m√©dia
‚Ä¢ Reset di√°rio com resumo

ü§ñ **Sistema funcionando:**
‚Ä¢ Verifica√ß√µes a cada 5 minutos
‚Ä¢ Monitoramento de {len(self.teams_data)} equipes
‚Ä¢ Cobertura de 6 continentes
            """
            
            if immediate_games > 0:
                response += f"\n\nüö® **JOGOS J√Å DETECTADOS HOJE:** {immediate_games}\nüìÖ Use `/jogos_hoje` para ver detalhes"
            else:
                response += f"\n\nüîç **Pr√≥xima verifica√ß√£o:** Em at√© 5 minutos"
            
            response += f"\n\nüìä Digite `/status_auto` para ver detalhes completos"
            
            await update.message.reply_text(response, parse_mode='Markdown')
            logger.info(f"üîî Usu√°rio {user_id} ativou alertas autom√°ticos")

    async def pause_alerts_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Pausa/desativa alertas autom√°ticos"""
        user_id = update.effective_user.id
        
        if user_id in self.monitored_users:
            self.monitored_users.remove(user_id)
            await update.message.reply_text(
                "‚è∏Ô∏è **ALERTAS PAUSADOS!**\n\n"
                "‚ùå Voc√™ n√£o receber√° mais alertas autom√°ticos\n"
                "üîÑ Para reativar: `/ativar_alertas`\n"
                "üìã Comandos manuais continuam funcionando\n\n"
                "üí° **Comandos dispon√≠veis:**\n"
                "‚Ä¢ `/jogos_hoje` - Ver jogos detectados\n"
                "‚Ä¢ `/analise [equipe]` - An√°lise manual\n"
                "‚Ä¢ `/equipes` - Lista completa\n"
                "‚Ä¢ `/status_auto` - Status do sistema",
                parse_mode='Markdown'
            )
            logger.info(f"‚è∏Ô∏è Usu√°rio {user_id} pausou alertas autom√°ticos")
        else:
            await update.message.reply_text(
                "‚ÑπÔ∏è **Alertas j√° est√£o pausados**\n\n"
                "üîî Para ativar: `/ativar_alertas`\n"
                "üìä Para ver status: `/status_auto`\n"
                "üìÖ Para ver jogos detectados: `/jogos_hoje`",
                parse_mode='Markdown'
            )

    async def games_today_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Mostra jogos detectados hoje"""
        if not self.detected_games:
            await update.message.reply_text(
                "üìÖ **JOGOS HOJE**\n\n"
                "‚ùå Nenhum jogo detectado ainda\n\n"
                "üîç **Sistema verificando:**\n"
                "‚Ä¢ A cada 5 minutos\n"
                "‚Ä¢ 102 equipes cadastradas\n"
                "‚Ä¢ M√∫ltiplas competi√ß√µes\n\n"
                "üîî Ative alertas: `/ativar_alertas`\n"
                "‚è∞ Pr√≥xima verifica√ß√£o: em breve...",
                parse_mode='Markdown'
            )
            return
        
        response = f"üìÖ **JOGOS DETECTADOS HOJE** ({len(self.detected_games)} jogos)\n\n"
        
        sorted_games = sorted(self.detected_games.items(), key=lambda x: x[1]["kickoff"])
        
        for game_key, game_data in sorted_games:
            home_team = game_data["home_team"]
            away_team = game_data["away_team"]
            kickoff = game_data["kickoff"]
            competition = game_data["competition"]
            
            # Status das equipes
            home_status = "‚úÖ" if game_data["home_in_db"] else "‚ùå"
            away_status = "‚úÖ" if game_data["away_in_db"] else "‚ùå"
            
            response += f"‚öΩ **{home_team}** {home_status} vs **{away_team}** {away_status}\n"
            response += f"üïí {kickoff} | üèÜ {competition}\n"
            
            # An√°lise r√°pida
            if home_team in self.teams_data:
                home_percent = self.teams_data[home_team]["zero_percent"]
                home_tier = self.teams_data[home_team]["tier"]
                tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
                response += f"üè† {home_team}: {home_percent}% {tier_emoji[home_tier]}\n"
            
            if away_team in self.teams_data:
                away_percent = self.teams_data[away_team]["zero_percent"] 
                away_tier = self.teams_data[away_team]["tier"]
                tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
                response += f"‚úàÔ∏è {away_team}: {away_percent}% {tier_emoji[away_tier]}\n"
            
            response += "\n"
        
        response += "üí° **An√°lise detalhada:** `/analise [nome da equipe]`\n"
        response += "üîî **Alertas autom√°ticos:** `/ativar_alertas`"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def auto_status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Status do sistema autom√°tico"""
        user_id = update.effective_user.id
        alerts_status = "üîî ATIVADOS" if user_id in self.monitored_users else "‚è∏Ô∏è PAUSADOS"
        
        # Calcular pr√≥xima verifica√ß√£o (aproximado)
        next_check_minutes = 5  # M√°ximo entre verifica√ß√µes
        
        response = f"""
ü§ñ **STATUS DO SISTEMA AUTOM√ÅTICO**

üìä **Seu Status:**
‚Ä¢ **Alertas:** {alerts_status}
‚Ä¢ **Pr√≥xima verifica√ß√£o:** Em at√© {next_check_minutes} minutos

üìà **Estat√≠sticas Gerais:**
‚Ä¢ **Usu√°rios monitorados:** {len(self.monitored_users)}
‚Ä¢ **Jogos detectados hoje:** {len(self.detected_games)}
‚Ä¢ **Equipes cadastradas:** {len(self.teams_data)}
‚Ä¢ **Continentes:** 6 (Europa, Am√©ricas, √Åsia, √Åfrica, Oceania)

‚öôÔ∏è **Configura√ß√µes:**
‚Ä¢ **Intervalo de verifica√ß√£o:** 5 minutos
‚Ä¢ **Reset di√°rio:** 06:00 
‚Ä¢ **Competi√ß√µes:** Ligas nacionais + internacionais

üîÑ **Sistema:** Ativo e funcionando
        """
        
        if self.detected_games:
            response += f"\n\nüéØ **Ver jogos detectados:** `/jogos_hoje`"
        
        if user_id not in self.monitored_users:
            response += f"\n\nüîî **Ativar alertas:** `/ativar_alertas`"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    # ========== COMANDOS MANUAIS (mantidos da vers√£o anterior) ==========
    
    async def teams_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Lista todas as equipes"""
        # Organizar por continente
        continents = {}
        for team, info in self.teams_data.items():
            continent = info["continent"]
            if continent not in continents:
                continents[continent] = []
            continents[continent].append((team, info))
        
        response = f"üåç **EQUIPES MONITORADAS AUTOMATICAMENTE** ({len(self.teams_data)} total)\n\n"
        
        for continent, teams in continents.items():
            response += f"üåü **{continent.upper()}** ({len(teams)} equipes)\n"
            
            # Ordenar por % de 0x0
            teams.sort(key=lambda x: x[1]["zero_percent"])
            
            # Mostrar apenas top 3 por continente para n√£o fazer mensagem muito longa
            for team, info in teams[:3]:
                tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
                response += f"{tier_emoji[info['tier']]} {team} - {info['zero_percent']}%\n"
            
            if len(teams) > 3:
                response += f"... e mais {len(teams)-3} equipes\n"
            
            response += "\n"
        
        response += "\nü§ñ **Sistema autom√°tico detecta jogos dessas equipes!**\n"
        response += "üîî **Ativar alertas:** `/ativar_alertas`\n"
        response += "üìä **Ver completa:** `/elite` (top 15)"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def analysis_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """An√°lise completa com verifica√ß√£o de jogo hoje"""
        if not context.args:
            await update.message.reply_text(
                "‚ùå **Uso:** `/analise [nome da equipe]`\n"
                "üí° **Exemplo:** `/analise FC Porto`\n"
                "üìã **Equipes:** `/equipes`\n"
                "ü§ñ **Autom√°tico:** `/ativar_alertas`",
                parse_mode='Markdown'
            )
            return
        
        team_name = " ".join(context.args)
        
        # Busca flex√≠vel
        found_team = None
        for team in self.teams_data.keys():
            if team_name.lower() in team.lower() or team.lower() in team_name.lower():
                found_team = team
                break
        
        if not found_team:
            await update.message.reply_text(
                f"‚ùå **'{team_name}' n√£o encontrada**\n"
                f"üìã `/equipes` para ver dispon√≠veis\n"
                f"ü§ñ Sistema autom√°tico monitora apenas equipes cadastradas",
                parse_mode='Markdown'
            )
            return
        
        # An√°lise completa
        team_info = self.teams_data[found_team]
        cash_out = self.get_cash_out_recommendation(found_team)
        
        # Verificar se tem jogo hoje
        game_today = None
        for game_data in self.detected_games.values():
            if found_team in [game_data["home_team"], game_data["away_team"]]:
                game_today = game_data
                break
        
        tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
        
        response = f"""
üèÜ **{found_team.upper()}** {tier_emoji[team_info['tier']]}

üìä **ESTAT√çSTICAS:**
‚Ä¢ **Liga:** {team_info['league']} ({team_info['continent']})
‚Ä¢ **% de 0x0:** {team_info['zero_percent']}% (√∫ltimos 3 anos)
‚Ä¢ **Tier:** {team_info['tier'].capitalize()}

üí∞ **CASH OUT:**
‚Ä¢ **A√ß√£o:** {cash_out['recommendation']}
‚Ä¢ **Confian√ßa:** {cash_out['confidence']}
‚Ä¢ **Decis√£o:** {cash_out['action']}
‚Ä¢ **Motivo:** {cash_out['reason']}
        """
        
        if game_today:
            opponent = game_today["away_team"] if found_team == game_today["home_team"] else game_today["home_team"]
            home_away = "üè† Casa" if found_team == game_today["home_team"] else "‚úàÔ∏è Fora"
            
            response += f"""

üö® **JOGO HOJE DETECTADO AUTOMATICAMENTE!**
‚Ä¢ **Advers√°rio:** {opponent}
‚Ä¢ **Hor√°rio:** {game_today['kickoff']}
‚Ä¢ **Local:** {home_away}
‚Ä¢ **Competi√ß√£o:** {game_today['competition']}
‚Ä¢ **Status:** Monitoramento autom√°tico ativo ‚úÖ

ü§ñ **Sistema autom√°tico j√° enviou alertas para usu√°rios ativos!**
            """
        else:
            response += f"""

üìÖ **PR√ìXIMOS JOGOS:**
‚Ä¢ Nenhum jogo detectado hoje
‚Ä¢ Sistema verifica automaticamente a cada 5min
‚Ä¢ Ative alertas: `/ativar_alertas`

üîç **√öltima verifica√ß√£o:** Sistema ativo
            """
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def elite_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Top 15 equipes com menor % de 0x0"""
        
        # Ordenar por % de 0x0
        all_teams = [(team, info) for team, info in self.teams_data.items()]
        all_teams.sort(key=lambda x: x[1]["zero_percent"])
        
        response = "üëë **TOP 15 EQUIPES ELITE** (menor % de 0x0)\n\n"
        
        for i, (team, info) in enumerate(all_teams[:15], 1):
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"{i:2d}."
            tier_emoji = {"elite": "üëë", "premium": "‚≠ê", "standard": "üî∏"}
            
            # Verificar se joga hoje
            plays_today = ""
            for game_data in self.detected_games.values():
                if team in [game_data["home_team"], game_data["away_team"]]:
                    plays_today = " üö®"
                    break
            
            response += f"{medal} {tier_emoji[info['tier']]} **{team}**{plays_today}\n"
            response += f"    {info['zero_percent']}% | {info['league']}\n\n"
        
        response += "üí° **An√°lise detalhada:** `/analise [nome da equipe]`\n"
        response += "üö® **Joga hoje:** Sistema detectou automaticamente\n"
        response += "üîî **Alertas:** `/ativar_alertas`"
        
        await update.message.reply_text(response, parse_mode='Markdown')

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipulador de erros"""
        logger.error(f"Erro: {context.error}")
        
        if update and update.message:
            await update.message.reply_text(
                "‚ùå **Erro interno**\n"
                "üîÑ Tente novamente\n"  
                "ü§ñ Sistema autom√°tico continua funcionando\n"
                "üìä Status: `/status_auto`",
                parse_mode='Markdown'
            )

def main():
    """Fun√ß√£o principal com sistema autom√°tico SEM AIOHTTP"""
    
    TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    if not TOKEN:
        logger.error("‚ùå TELEGRAM_BOT_TOKEN n√£o encontrado!")
        sys.exit(1)
    
    logger.info("üöÄ Iniciando Bot Autom√°tico de Monitoramento...")
    
    # Criar inst√¢ncia do bot autom√°tico
    bot = AutomaticFootballBot()
    
    # Criar aplica√ß√£o
    application = Application.builder().token(TOKEN).build()
    
    # Registrar comandos autom√°ticos
    application.add_handler(CommandHandler("start", bot.start_command))
    application.add_handler(CommandHandler("ativar_alertas", bot.activate_alerts_command))
    application.add_handler(CommandHandler("pausar_alertas", bot.pause_alerts_command))
    application.add_handler(CommandHandler("jogos_hoje", bot.games_today_command))
    application.add_handler(CommandHandler("status_auto", bot.auto_status_command))
    
    # Comandos manuais
    application.add_handler(CommandHandler("equipes", bot.teams_command))
    application.add_handler(CommandHandler("analise", bot.analysis_command))
    application.add_handler(CommandHandler("elite", bot.elite_command))
    
    # Handler de erro
    application.add_error_handler(bot.error_handler)
    
    logger.info(f"‚úÖ Bot autom√°tico carregado - {len(bot.teams_data)} equipes!")
    logger.info("ü§ñ Sistema de monitoramento autom√°tico iniciar√° em 10 segundos...")
    
    # Executar com polling
    try:
        # Iniciar sistema autom√°tico ap√≥s aplica√ß√£o iniciar
        async def post_init(application):
            await bot.start_automatic_monitoring(application)
        
        application.post_init = post_init
        
        application.run_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True,
            poll_interval=1.0,
            timeout=10
        )
    except Exception as e:
        logger.error(f"‚ùå Erro: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
